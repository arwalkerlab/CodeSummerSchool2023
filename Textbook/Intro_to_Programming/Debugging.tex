%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Debugging}
Debugging code is often a team effort, because invariably the person who wrote the code might wind up missing some of their own mistakes that others will readily find. 
This is not at all an indicator of skill, intelligence, or character. 
This is purely because we can get tunnel vision about our own code (it happens to the best of us), and because our brains are wired to recognize \emph{and complete} patterns.
Where we might ``see'' a missing semicolon at the end of a line of code we wrote because we expect it to be there, someone else who didn't write our code may notice it immediately. 
Interestingly, debugging is actually a \emph{highly} valued skill in industry, because fixing problems is usually far more expensive than preventing them in the first place.

It's often said that only a small portion of programming is actually
writing the code - the rest is fixing the code.

Debugging is required at multiple stages of programming, and bugs can
arise in many different forms.

\hypertarget{compilation-bugs}{%
\paragraph{Compilation Bugs}\label{compilation-bugs}}

Compilation errors are usually the easiest to solve, as they're
encountered by the compiler itself and are often syntax-related
(``missing semicolon on line 85'') or datatype-related (``Unable to cast
string as int''), and usually include ``tracebacks'' which can help you
figure out where exactly the error is.

\hypertarget{runtime-bugs}{%
\paragraph{Runtime Bugs}\label{runtime-bugs}}

There are a few kinds of runtime errors that can pop up. They are
usually more complicated to unravel, depending on what caused them. The
first kind is something that, while the code will compile fine, the
actual execution will return an error. For example, a function that
takes \texttt{x} and \texttt{y} and returns the result of \texttt{x/y}
may compile just fine. But when you run the code, if somehow
\texttt{y\ =\ 0}, the program will crash because of an attempt to divide
by zero.

Another bug that can arise is when the results are not what was
expected. For instance, if you have a program that should return the
product of two numbers, and instead returns the sum of the two numbers,
this is a runtime error, even though no error is actually reported. The
code compiles fine and executes exactly as it is written, but it may not
be what was intended. These types of bugs are why validation and testing
are required for programs big and small.

Take a look at the code blocks below. One contains an example of a
compilation error, the other a runtime error.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n+nb}{int} \PY{n}{x} \PY{o}{=} \PY{l+m+mi}{45}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{x}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}, frame=single, framerule=2mm, rulecolor=\color{outerrorbackground}]
\textcolor{ansi-cyan}{  File }\textcolor{ansi-green}{"/tmp/ipykernel\_10751/2716038442.py"}\textcolor{ansi-cyan}{, line }\textcolor{ansi-green}{1}
\textcolor{ansi-red}{    int x = 45}
        \^{}
\textcolor{ansi-red}{SyntaxError}\textcolor{ansi-red}{:} invalid syntax

    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{divide}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{x}\PY{o}{/}\PY{n}{y}

\PY{n}{x} \PY{o}{=} \PY{l+m+mi}{5}
\PY{n}{y} \PY{o}{=} \PY{l+m+mi}{1}
\PY{n}{result} \PY{o}{=} \PY{n}{divide}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{result}\PY{p}{)}

\PY{n}{x} \PY{o}{=} \PY{l+m+mi}{5}
\PY{n}{y} \PY{o}{=} \PY{l+m+mi}{0}
\PY{n}{result} \PY{o}{=} \PY{n}{divide}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{result}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
5 1 5.0
    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}, frame=single, framerule=2mm, rulecolor=\color{outerrorbackground}]
\textcolor{ansi-red}{---------------------------------------------------------------------------}
\textcolor{ansi-red}{ZeroDivisionError}                         Traceback (most recent call last)
\textcolor{ansi-green}{/tmp/ipykernel\_10751/1166490746.py} in \textcolor{ansi-cyan}{<module>}
\textcolor{ansi-green-intense}{\textbf{      9}} x \textcolor{ansi-blue}{=} \textcolor{ansi-cyan}{5}
\textcolor{ansi-green-intense}{\textbf{     10}} y \textcolor{ansi-blue}{=} \textcolor{ansi-cyan}{0}
\textcolor{ansi-green}{---> 11}\textcolor{ansi-red}{ }result \textcolor{ansi-blue}{=} divide\textcolor{ansi-blue}{(}x\textcolor{ansi-blue}{,}y\textcolor{ansi-blue}{)}
\textcolor{ansi-green-intense}{\textbf{     12}} print\textcolor{ansi-blue}{(}x\textcolor{ansi-blue}{,}y\textcolor{ansi-blue}{,}result\textcolor{ansi-blue}{)}
\textcolor{ansi-green-intense}{\textbf{     13}} 

\textcolor{ansi-green}{/tmp/ipykernel\_10751/1166490746.py} in \textcolor{ansi-cyan}{divide}\textcolor{ansi-blue}{(x, y)}
\textcolor{ansi-green-intense}{\textbf{      1}} \textcolor{ansi-green}{def} divide\textcolor{ansi-blue}{(}x\textcolor{ansi-blue}{,}y\textcolor{ansi-blue}{)}\textcolor{ansi-blue}{:}
\textcolor{ansi-green}{----> 2}\textcolor{ansi-red}{     }\textcolor{ansi-green}{return} x\textcolor{ansi-blue}{/}y
\textcolor{ansi-green-intense}{\textbf{      3}} 
\textcolor{ansi-green-intense}{\textbf{      4}} x \textcolor{ansi-blue}{=} \textcolor{ansi-cyan}{5}
\textcolor{ansi-green-intense}{\textbf{      5}} y \textcolor{ansi-blue}{=} \textcolor{ansi-cyan}{1}

\textcolor{ansi-red}{ZeroDivisionError}: division by zero
    \end{Verbatim}

    It should be pointed out that \emph{technically}, \texttt{Python}
doesn't have compile errors since it's not compiled at all, but runs
like a scripting language which merely interprets the commands line by
line. However, more advanced python programming can include the actual
compilation of python scripts into self-contained programs that don't
require any external libraries. This is not in the scope of this
workshop, however, and is merely pointed out for information.
