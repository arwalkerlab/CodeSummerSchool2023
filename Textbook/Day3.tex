\chapter{Day 3 - Python Functions}
\section{Basic Functions}
A function in programming is similar to a function in math - variables
go in, operations occur, results come out. In fact, I passed all my
higher level math classes by learning to reinterpret
complex mathematical equations as programming functions. For example, if
you wanted to obtain the sum of all integers between 0 and 1000, you
would do the following:

\textbf{Math}

\(\sum\limits_{x=0}^{1000}x\)

\textbf{Python}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{total }\OperatorTok{=} \DecValTok{0}
\ControlFlowTok{for}\NormalTok{ x }\KeywordTok{in} \BuiltInTok{range}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1001}\NormalTok{):}
\NormalTok{    total }\OperatorTok{+=}\NormalTok{ x}
\BuiltInTok{print}\NormalTok{(total)}
\end{Highlighting}
\end{Shaded}

\textbf{C++}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ total }\OperatorTok{=} \DecValTok{0}\OperatorTok{;}
\ControlFlowTok{for}\OperatorTok{(}\DataTypeTok{int}\NormalTok{ x}\OperatorTok{=}\DecValTok{0}\OperatorTok{;}\NormalTok{x}\OperatorTok{\textless{}=}\DecValTok{1000}\OperatorTok{;}\NormalTok{x}\OperatorTok{++)}
\OperatorTok{\{}
\NormalTok{    total }\OperatorTok{+=}\NormalTok{ x}\OperatorTok{;}
\OperatorTok{\}}
\NormalTok{cout }\OperatorTok{\textless{}\textless{}}\NormalTok{ total }\OperatorTok{\textless{}\textless{}}\NormalTok{ endl}\OperatorTok{;}
\end{Highlighting}
\end{Shaded}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

The functions above produce the same value. They are simply different
representations of the same algorithm.

\emph{What do you notice that's different between these two programming
languages?}

If you find there's a task or set of instructions that you do multiple
times in a program/script, you might find it useful to convert it into a
function.

Functions have the benefit of ensuring that the calculations are being
performed consistently - you only have to get the code right once!

However, it's also important to consider if something is \textbf{worth}
turning into a function. Whenever you think about building a function,
the first thing to do is see if it already exists. This is a fundamental
rule for programming and science - don't reinvent the wheel unless you
can make it a lot better.

\hypertarget{python-functions}{%
\subsubsection{Python Functions}\label{python-functions}}

For today, we'll focus on python functions.

    \emph{A function to return the remainder of one number divided by
another. That might look somethink like this:}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{def}\NormalTok{ get\_remainder(number,divisor):}
    \ControlFlowTok{if}\NormalTok{ number }\OperatorTok{\textgreater{}}\NormalTok{ divisor:}
        \ControlFlowTok{return}\NormalTok{ get\_remainder(number}\OperatorTok{{-}}\NormalTok{divisor,divisor)}
    \ControlFlowTok{else}\NormalTok{:}
        \ControlFlowTok{return}\NormalTok{ number}
\end{Highlighting}
\end{Shaded}

Experienced programmers will look at the function above and consider
hunting me down. Rightfully so, for multiple reasons. First and most
importantly, the function is unnecessary. There already exists a
function to get the remainder of a number and a divisor, called
``modulo'', and is called using \texttt{\%} like so:

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{l+m+mi}{23}\PY{o}{\PYZpc{}}\PY{k}{5}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
3
\end{Verbatim}
\end{tcolorbox}
        
    That is so much easier than writing the function above. However, that's
not the only reason the function above will drive programmers nuts:
\textbf{\href{https://www.google.com/search?biw=924\&bih=939\&sxsrf=ALiCzsYF5yDBRHIPvQK0WvoahmOQWNTLaw:1652715574983\&q=recursion\&spell=1\&sa=X\&ved=2ahUKEwjhw4umreT3AhVBCjQIHQeACCYQBSgAegQIAhAy}{Recursion}}

Recursive functions are any function that calls itself during its
execution. While there are some situations where recursion may be
necessary, There is nearly always a cleaner solution.

The problems with recursion lie in the fact that such a function can
call itself infinitely if not well-written, and can become
computationally expensive and slow. So if you ever find yourself writing
a function that calls itself, get another opinion from someone else.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

Okay, let's start at the basics of writing a function in Python

Every function must be \emph{defined} before it can be \emph{called}
(used). In Python, a function definition begins with the command
\texttt{def}, followed by the name of the function and then any function
\emph{arguments} it will need. \emph{Arguments} are named variables that
will be used inside the function. This means that any needed variables
that aren't given to the function as an argument must be created inside
the function. After the arguments, you need a \texttt{:} to indicate
that the following code is what should be executed whenever the function
is called. It's also good practice to include the \texttt{return}
command at the end of the function, even if nothing is sent back to
where the function was called.

An example is below.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{myfunction}\PY{p}{(}\PY{n}{argument1}\PY{p}{,}\PY{n}{argument2}\PY{p}{,}\PY{n}{argument3}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{n}{argument1}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{n}{argument2}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{n}{argument3}\PY{p}{)}
    \PY{k}{return}
\end{Verbatim}
\end{tcolorbox}

    This is a fairly simple function, and now that we've defined it, we can
call it as much as we want.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{myfunction}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{potato}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{nebula}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{agreeable}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
potato
nebula
agreeable
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{myfunction}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mf}{78.951}\PY{p}{,}\PY{l+m+mi}{9001}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
4
78.951
9001
    \end{Verbatim}

    Note that the two different calls above pass different types of data to
the function, but the function is able to handle them all. Let's try a
different function that does some math on the variables we pass it.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{mymathfunction}\PY{p}{(}\PY{n}{arg1}\PY{p}{,}\PY{n}{arg2}\PY{p}{,}\PY{n}{arg3}\PY{p}{)}\PY{p}{:}
    \PY{n}{result} \PY{o}{=} \PY{n}{arg1} \PY{o}{+} \PY{n}{arg2} \PY{o}{\PYZhy{}} \PY{n}{arg3}
    \PY{k}{return} \PY{n}{result}
\end{Verbatim}
\end{tcolorbox}

    Now, looking at the function above, we expect it to use numbers as
arguments.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{answer} \PY{o}{=} \PY{n}{mymathfunction}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{answer}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
12
    \end{Verbatim}

    What if we passed data that wasn't a number?

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{answer} \PY{o}{=} \PY{n}{mymathfunction}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cactus}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{answer}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}, frame=single, framerule=2mm, rulecolor=\color{outerrorbackground}]
\textcolor{ansi-red}{---------------------------------------------------------------------------}
\textcolor{ansi-red}{TypeError}                                 Traceback (most recent call last)
Input \textcolor{ansi-green}{In [7]}, in \textcolor{ansi-cyan}{<cell line: 1>}\textcolor{ansi-blue}{()}
\textcolor{ansi-green}{----> 1} answer \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{=} \setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{mymathfunction\strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{(\strut}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{5\strut}}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{,\strut}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{10\strut}}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{,\strut}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{175,0,0}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{"\strut}}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{175,0,0}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{cactus\strut}}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{175,0,0}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{"\strut}}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{)\strut}
\textcolor{ansi-green-intense}{\textbf{      2}} \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{0,135,0}}{print}(answer)

Input \textcolor{ansi-green}{In [5]}, in \textcolor{ansi-cyan}{mymathfunction}\textcolor{ansi-blue}{(arg1, arg2, arg3)}
\textcolor{ansi-green-intense}{\textbf{      1}} \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{0,135,0}}{\textbf{def}} \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{0,0,255}}{mymathfunction}(arg1,arg2,arg3):
\textcolor{ansi-green}{----> 2}     result \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{=} \setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{arg1\strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{ \strut}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{+\strut}}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{ \strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{arg2\strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{ \strut}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{-\strut}}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{ \strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{arg3\strut}
\textcolor{ansi-green-intense}{\textbf{      3}}     \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{0,135,0}}{\textbf{return}} result

\textcolor{ansi-red}{TypeError}: unsupported operand type(s) for -: 'int' and 'str'
    \end{Verbatim}

    Now we get a type error. Fortunately, we can rewrite the function to
include ``type hints''. If we add \texttt{:float} after the variable
names in the function definition, we're telling the programmer ``This
variable should be of the \texttt{float} data type''. Please note that
it doesn't actually stop the user from passing incorrect data types to
the function.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{mymathfunction}\PY{p}{(}\PY{n}{arg1}\PY{p}{:}\PY{n+nb}{float}\PY{p}{,} \PY{n}{arg2}\PY{p}{:}\PY{n+nb}{float}\PY{p}{,} \PY{n}{arg3}\PY{p}{:}\PY{n+nb}{float}\PY{p}{)}\PY{p}{:}
    \PY{n}{result} \PY{o}{=} \PY{n}{arg1} \PY{o}{+} \PY{n}{arg2} \PY{o}{\PYZhy{}} \PY{n}{arg3}
    \PY{k}{return} \PY{n}{result}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{answer} \PY{o}{=} \PY{n}{mymathfunction}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cactus}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{answer}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}, frame=single, framerule=2mm, rulecolor=\color{outerrorbackground}]
\textcolor{ansi-red}{---------------------------------------------------------------------------}
\textcolor{ansi-red}{TypeError}                                 Traceback (most recent call last)
Input \textcolor{ansi-green}{In [9]}, in \textcolor{ansi-cyan}{<cell line: 1>}\textcolor{ansi-blue}{()}
\textcolor{ansi-green}{----> 1} answer \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{=} \setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{mymathfunction\strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{(\strut}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{5\strut}}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{,\strut}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{10\strut}}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{,\strut}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{175,0,0}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{"\strut}}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{175,0,0}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{cactus\strut}}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{175,0,0}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{"\strut}}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{)\strut}
\textcolor{ansi-green-intense}{\textbf{      2}} \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{0,135,0}}{print}(answer)

Input \textcolor{ansi-green}{In [8]}, in \textcolor{ansi-cyan}{mymathfunction}\textcolor{ansi-blue}{(arg1, arg2, arg3)}
\textcolor{ansi-green-intense}{\textbf{      1}} \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{0,135,0}}{\textbf{def}} \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{0,0,255}}{mymathfunction}(arg1:\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{0,135,0}}{float}, arg2:\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{0,135,0}}{float}, arg3:\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{0,135,0}}{float}):
\textcolor{ansi-green}{----> 2}     result \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{=} \setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{arg1\strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{ \strut}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{+\strut}}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{ \strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{arg2\strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{ \strut}\def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{98,98,98}}{\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{-\strut}}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{ \strut}\setlength{\fboxsep}{0pt}\colorbox{ansi-yellow}{arg3\strut}
\textcolor{ansi-green-intense}{\textbf{      3}}     \def\tcRGB{\textcolor[RGB]}\expandafter\tcRGB\expandafter{\detokenize{0,135,0}}{\textbf{return}} result

\textcolor{ansi-red}{TypeError}: unsupported operand type(s) for -: 'int' and 'str'
    \end{Verbatim}

    Recall the booleans we discussed yesterday. We can use them along with a
\emph{type check} in our function to first make sure the arguments to
our function are of the correct type.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{10}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} declare a variable as an integer.}
\PY{n}{x} \PY{o}{=} \PY{l+m+mi}{5}

\PY{c+c1}{\PYZsh{} check if it\PYZsq{}s an integer.}
\PY{n+nb}{print}\PY{p}{(}\PY{n+nb}{isinstance}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n+nb}{int}\PY{p}{)}\PY{p}{)}

\PY{c+c1}{\PYZsh{} check if it\PYZsq{}s a float.}
\PY{n+nb}{print}\PY{p}{(}\PY{n+nb}{isinstance}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n+nb}{float}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
True
False
    \end{Verbatim}

    We can see how the \texttt{isinstance} function (which doesn't need to
be defined because it's already part of the base python) takes the
variable we give it and a type, and returns a boolean response. Note
that the \texttt{int} and \texttt{float} checks return different
results. However, as programmers we know that python math with integers
and floats is (generally) interchangable.

How can we use this to guard our functions?

In the example below, we will create an empty list for the type checks,
then add the result of each check to the list. Then, if the whole list
is \texttt{True}, we will proceed with the function. If it's not all
\texttt{True}, we'll exit the function without doing anything.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{11}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{mymathfunction}\PY{p}{(}\PY{n}{arg1}\PY{p}{:}\PY{n+nb}{float}\PY{p}{,} \PY{n}{arg2}\PY{p}{:}\PY{n+nb}{float}\PY{p}{,} \PY{n}{arg3}\PY{p}{:}\PY{n+nb}{float}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} make an empty list}
    \PY{n}{variable\PYZus{}type\PYZus{}checks} \PY{o}{=} \PY{p}{[}\PY{p}{]}
    \PY{c+c1}{\PYZsh{} check if arg1 is a float or an integer and add the result to the list}
    \PY{n}{variable\PYZus{}type\PYZus{}checks}\PY{o}{.}\PY{n}{append}\PY{p}{(} \PY{n+nb}{any}\PY{p}{(} \PY{p}{[}\PY{n+nb}{isinstance}\PY{p}{(}\PY{n}{arg1}\PY{p}{,}\PY{n+nb}{float}\PY{p}{)}\PY{p}{,} \PY{n+nb}{isinstance}\PY{p}{(}\PY{n}{arg1}\PY{p}{,}\PY{n+nb}{int}\PY{p}{)}\PY{p}{]} \PY{p}{)} \PY{p}{)}
    \PY{c+c1}{\PYZsh{} check if arg2 is a float or an integer and add the result to the list}
    \PY{n}{variable\PYZus{}type\PYZus{}checks}\PY{o}{.}\PY{n}{append}\PY{p}{(} \PY{n+nb}{any}\PY{p}{(} \PY{p}{[}\PY{n+nb}{isinstance}\PY{p}{(}\PY{n}{arg2}\PY{p}{,}\PY{n+nb}{float}\PY{p}{)}\PY{p}{,} \PY{n+nb}{isinstance}\PY{p}{(}\PY{n}{arg2}\PY{p}{,}\PY{n+nb}{int}\PY{p}{)}\PY{p}{]} \PY{p}{)} \PY{p}{)}
    \PY{c+c1}{\PYZsh{} check if arg3 is a float or an integer and add the result to the list}
    \PY{n}{variable\PYZus{}type\PYZus{}checks}\PY{o}{.}\PY{n}{append}\PY{p}{(} \PY{n+nb}{any}\PY{p}{(} \PY{p}{[}\PY{n+nb}{isinstance}\PY{p}{(}\PY{n}{arg3}\PY{p}{,}\PY{n+nb}{float}\PY{p}{)}\PY{p}{,} \PY{n+nb}{isinstance}\PY{p}{(}\PY{n}{arg3}\PY{p}{,}\PY{n+nb}{int}\PY{p}{)}\PY{p}{]} \PY{p}{)} \PY{p}{)}

    \PY{c+c1}{\PYZsh{} check if the entire list is \PYZdq{}True\PYZdq{}}
    \PY{k}{if} \PY{n+nb}{all}\PY{p}{(}\PY{n}{variable\PYZus{}type\PYZus{}checks}\PY{p}{)}\PY{p}{:}
        \PY{n}{result} \PY{o}{=} \PY{n}{arg1} \PY{o}{+} \PY{n}{arg2} \PY{o}{\PYZhy{}} \PY{n}{arg3}
        \PY{k}{return} \PY{n}{result}
    \PY{c+c1}{\PYZsh{} if the above fails (the if\PYZhy{}condition is not met), we\PYZsq{}ll do the next section instead.}
    \PY{k}{elif} \PY{n+nb}{any}\PY{p}{(}\PY{n}{variable\PYZus{}type\PYZus{}checks}\PY{p}{)}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Some arguments are not floats.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{k}{return} \PY{k+kc}{None}
    \PY{c+c1}{\PYZsh{} if nothing above worked, do this.}
    \PY{k}{else}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Every argument is not a float!}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{k}{return} \PY{k+kc}{None}
\end{Verbatim}
\end{tcolorbox}

    This function is a bit larger, but it's including additional checks and
conditions to ensure it works correctly.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{12}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{answer} \PY{o}{=} \PY{n}{mymathfunction}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{answer}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
12
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{answer} \PY{o}{=} \PY{n}{mymathfunction}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cactus}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{answer}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Some arguments are not floats.
None
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{14}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{answer} \PY{o}{=} \PY{n}{mymathfunction}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cheese}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{crater}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cactus}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{answer}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Every argument is not a float!
None
    \end{Verbatim}

    We have the three possible outcomes for this function above. In all
cases, the function executed without throwing an error (which can cause
the program to crash entirely), and each returned a result.

The two ``failing'' function calls returned the \texttt{None} datatype.
In C++, this is called \texttt{NULL}. Both effectively mean there's an
empty spot. However, we can still treat \texttt{None} like a data type.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{15}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{answer} \PY{o}{=} \PY{n}{mymathfunction}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cheese}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{crater}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{cactus}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}

\PY{n}{answer} \PY{o}{==} \PY{k+kc}{None}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Every argument is not a float!
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{15}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
True
\end{Verbatim}
\end{tcolorbox}
        
    We can use the \texttt{None} comparison to check results, which can be
useful in larger functions or programs.

What if there are external values that you need to change inside the
function? By default, when you pass arguments to functions in Python,
you're not passing the variable itself, but a copy of the value inside.
Consider the function below.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{16}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{n}{x} \PY{o}{=} \PY{n}{x}\PY{o}{+}\PY{l+m+mi}{10}
    \PY{n+nb}{print}\PY{p}{(}\PY{n}{x}\PY{p}{)}

\PY{c+c1}{\PYZsh{} set x to a value}
\PY{n}{x} \PY{o}{=} \PY{l+m+mi}{5}
\PY{c+c1}{\PYZsh{} print the value of x}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{x}\PY{p}{)}
\PY{c+c1}{\PYZsh{} call the function f(x), which internally changes the value of x and then prints it}
\PY{n}{f}\PY{p}{(}\PY{n}{x}\PY{p}{)}
\PY{c+c1}{\PYZsh{} print the value of x}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{x}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
5
15
5
    \end{Verbatim}

    Now, here we can see that the value of \texttt{x} \emph{outside} the
function \texttt{f(x)} never changes, even though it's changed inside.
This is an example of \emph{scope} that we discussed yesterday. What if
we wanted to change the value of \texttt{x} with the function?

We can use \texttt{global} to pull variables in from the outside and
use/modify them. This is particularly useful when you're wanting to
change a large dataset, like a list of xyz-coordinates for a bunch of
particles (as a completely innocent and totally-not-foreshadowing
example).

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{17}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{k}{global} \PY{n}{y}
    \PY{n}{y} \PY{o}{=} \PY{n}{y}\PY{o}{+}\PY{l+m+mi}{10}

\PY{n}{y}\PY{o}{=}\PY{l+m+mi}{7}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{y}\PY{p}{)}
\PY{n}{f}\PY{p}{(}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{y}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
7
17
    \end{Verbatim}

    Now we see how the function \texttt{f()} without any arguments was able
to modify the value of \texttt{y} outside itself.

Now that you know about \texttt{global}, be aware that it can be very
dangerous if used improperly.
\begin{center}
\includegraphics[width=0.99\textwidth]{Images/DeathSword.png}
\end{center}
In Python, functions can pull external things inside with
\texttt{global}, but nothing can be pulled from inside a function except
things the function \emph{returns}.

You can also nest function calls inside other functions, which can be
useful as well.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{18}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2} \PY{o}{+} \PY{l+m+mi}{7}

\PY{k}{def} \PY{n+nf}{g}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{x}\PY{o}{*}\PY{n}{f}\PY{p}{(}\PY{n}{x}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{n}{g}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{g}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
-48
92
    \end{Verbatim}

    That's a very simple example, but you can see how having smaller
functions can lend itself to a modularity and reusability that can
become very convenient.
\section{Functions Project}
Let's try creating some other functions, perhaps based on the pseudocode
project from last time.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function to generate a random set of coordinates for a
  particle in a cube with an edge length of 20.
\item
  Write a function to create a list of \texttt{N} randomly placed
  particles.
\item
  Write a function to generate a random movement of a particle with each
  \texttt{x}, \texttt{y}, and \texttt{z} component of the motion vector
  as a random value between -1 and +1.
\item
  Write a function to make each particle in the list take \texttt{S}
  number of random motion steps.
\item
  Write a function to measure the distance between the starting and
  ending points of all particles.
\end{enumerate}

I will include some helper functions for things like random number
generation below. For all functions you'll write below, you will need to
choose what arguments you need to pass to the function and how to get to
the result at the \texttt{return} statement ending each function.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}

\PY{k}{def} \PY{n+nf}{random}\PY{p}{(}\PY{n}{lower}\PY{p}{,}\PY{n}{upper}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{uniform}\PY{p}{(}\PY{n}{low}\PY{o}{=}\PY{n}{lower}\PY{p}{,} \PY{n}{high}\PY{o}{=}\PY{n}{upper}\PY{p}{)}

\PY{k}{def} \PY{n+nf}{plot\PYZus{}distances}\PY{p}{(}\PY{n}{distances}\PY{p}{)}\PY{p}{:}
    \PY{n}{plt}\PY{o}{.}\PY{n}{hist}\PY{p}{(}\PY{n}{distances}\PY{p}{,} \PY{n}{bins}\PY{o}{=}\PY{l+m+mi}{100}\PY{p}{,} \PY{n}{density}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Generate particle with random position [x,y,z]}
\PY{k}{def} \PY{n+nf}{CreateParticle}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Your code goes here!}

    \PY{k}{return} \PY{n}{particle}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Create a list of N randomly generated particles}
\PY{k}{def} \PY{n+nf}{GenerateParticleCollection}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Your code goes here!}
    
    \PY{k}{return} \PY{n}{all\PYZus{}particles}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} generate a random motion between \PYZhy{}1 and 1 in all axes and apply it to a given particle.}
\PY{k}{def} \PY{n+nf}{MoveParticle}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Your code goes here!}

    \PY{k}{return} \PY{n}{new\PYZus{}position}
    
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Move all particles in your list S number of times and return the final positions.}
\PY{k}{def} \PY{n+nf}{BrownianMotionSimulation}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Your code goes here!}
    
    \PY{k}{return} \PY{n}{final\PYZus{}positions}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Compare starting and ending positions for all particles and return the distances.}
\PY{k}{def} \PY{n+nf}{CalculateDistances}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Your code goes here!}

    \PY{k}{return} \PY{n}{distances}
\end{Verbatim}
\end{tcolorbox}

    Now write a sequence of function calls, variable assignments, etc. to
run through your algorithm.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} This is your main \PYZdq{}program\PYZdq{}, which will use the functions you\PYZsq{}ve written and return a nice histogram of the resulting distances traveled by each particle.}

\PY{c+c1}{\PYZsh{} Generate 10000 particles}

\PY{c+c1}{\PYZsh{} Move the particles 100 steps.}

\PY{c+c1}{\PYZsh{} Measure the distances between starting and ending positions.}

\PY{c+c1}{\PYZsh{} use the `plot\PYZus{}distances()` function call to show the results as a histogram.}
\end{Verbatim}
\end{tcolorbox}

    If you got a histogram plot that looks like it could be the results of
the random motion of 10,000 particles, your program probably works
great!

Now that we've all completed that, let's consider some additional things
about the algorithm and the \emph{actual} execution of it.

For example, does the distance travelled have any dependency on the
original position of the particles? If not, what can we do to reduce the
amount of work being done by the computer? Can we reduce the entire
program down to something smaller?

Programming is often thought of as ``make the computer do a task'',
which is true, but in the larger picture of scientific programming, it's
important to consider the actual goals.

If we re-examine the actual goal of ``obtain a distribution of how far
particles will travel given random motion'', we can reduce the algorithm
down significantly.

\begin{itemize}
\tightlist
\item
  The x, y, and z components of motion are all generated the same way
  and independently of each other.
\item
  Each particle's motion is independent of all the other particles, as
  is its final distance traveled.
\item
  The final distance is independent of the starting coordinates.
\end{itemize}

With these points in mind, can you think of a new form of the algorithm?

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} start empty list of distances}
\PY{c+c1}{\PYZsh{} loop through number of particles to test}
    \PY{c+c1}{\PYZsh{} start particle position at 0,0,0}
    \PY{c+c1}{\PYZsh{} make S number of x moves, sum them up to a final x position}
    \PY{c+c1}{\PYZsh{} make S number of y moves, sum them up to a final y position}
    \PY{c+c1}{\PYZsh{} make S number of z moves, sum them up to a final z position}
    \PY{c+c1}{\PYZsh{} calculate norm of x,y,z coordinates}
    \PY{c+c1}{\PYZsh{} append norm to list of distances.}
\PY{c+c1}{\PYZsh{} plot histogram of distances}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{distances} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10000}\PY{p}{)}\PY{p}{:}
    \PY{n}{x}\PY{o}{=}\PY{l+m+mi}{0}
    \PY{n}{y}\PY{o}{=}\PY{l+m+mi}{0}
    \PY{n}{z}\PY{o}{=}\PY{l+m+mi}{0}
    \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{:}
        \PY{n}{x} \PY{o}{+}\PY{o}{=} \PY{n}{random}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
        \PY{n}{y} \PY{o}{+}\PY{o}{=} \PY{n}{random}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
        \PY{n}{z} \PY{o}{+}\PY{o}{=} \PY{n}{random}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{n}{norm} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{norm}\PY{p}{(}\PY{p}{[}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{z}\PY{p}{]}\PY{p}{)}
    \PY{n}{distances}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{norm}\PY{p}{)}

\PY{n}{plot\PYZus{}distances}\PY{p}{(}\PY{n}{distances}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_11_1.png}
    \end{center}
    { \hspace*{\fill} \\}
\section{Intermediate Functions - args and kwargs}
What if you wanted to give a function an unknown number of arguments?
Say, for example, you wanted to give it some random number of
\texttt{float} values and have it multiply the reciprocals of each
together? The mathematical formula would look like this:

\(\prod\limits_{i=1}\frac{1}{x_i}\)

The Python function can use \texttt{*args} as an argument. The
\texttt{*} indicates the value is going to be some arbitrary length list
of values that should be collected by the function.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{29}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{product\PYZus{}of\PYZus{}reciprocals}\PY{p}{(}\PY{o}{*}\PY{n}{args}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{} Start with the product set to 1 (since anything multiplied by one is itself).}
    \PY{n}{product}\PY{o}{=}\PY{l+m+mi}{1}
    \PY{k}{for} \PY{n}{arg} \PY{o+ow}{in} \PY{n}{args}\PY{p}{:} \PY{c+c1}{\PYZsh{} iterate through all the values given in the function call}
        \PY{n}{product} \PY{o}{=} \PY{n}{product} \PY{o}{*} \PY{p}{(}\PY{l+m+mi}{1}\PY{o}{/}\PY{n}{arg}\PY{p}{)} \PY{c+c1}{\PYZsh{} multiply the current product value by the reciprocal of the current arg value, and assign it to the product value}
    \PY{k}{return} \PY{n}{product}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{30}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{product\PYZus{}of\PYZus{}reciprocals}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{30}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
1
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{31}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{product\PYZus{}of\PYZus{}reciprocals}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+m+mi}{95}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{31}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
0.0005847953216374268
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{32}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{product\PYZus{}of\PYZus{}reciprocals}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{11}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{32}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
0.0003787878787878788
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{36}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{product\PYZus{}of\PYZus{}reciprocals}\PY{p}{(}\PY{l+m+mf}{0.1}\PY{p}{,} \PY{l+m+mf}{0.2}\PY{p}{,} \PY{l+m+mf}{0.5}\PY{p}{,} \PY{l+m+mf}{1.0}\PY{p}{,} \PY{l+m+mf}{1.5}\PY{p}{,} \PY{l+m+mf}{2.0}\PY{p}{,} \PY{l+m+mf}{5.0}\PY{p}{,} \PY{l+m+mf}{7.0}\PY{p}{,} \PY{l+m+mf}{10.0002}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{36}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
0.09523619051428493
\end{Verbatim}
\end{tcolorbox}
        
    With \texttt{*args}, any number of values may be passed to the function.

What about unknown and arbitrary number of arguments that must be
assigned to specific keywords?

Here, we can use \texttt{**kwargs}, which is short for ``keyword
arguments''. This specifically requires that each additional argument be
given as a variable and an assignment. These can be useful if there are
specific things you want your function to do, but only if those
arguments are present.

The \texttt{**} indicates that \texttt{kwargs} will be a
\texttt{dictionary} data type, which is a list of mapped keys and
values. Therefore, using the individual keywords requires a little
knowledge of dictionary manipulation.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{39}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{PrintKwargs}\PY{p}{(}\PY{o}{*}\PY{o}{*}\PY{n}{kwargs}\PY{p}{)}\PY{p}{:}
    \PY{k}{for} \PY{n}{key}\PY{p}{,}\PY{n}{val} \PY{o+ow}{in} \PY{n}{kwargs}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{key}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{says}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{val}\PY{p}{)}
    \PY{k}{return}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{41}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{PrintKwargs}\PY{p}{(}\PY{n}{chicken}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{bawk}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{cow}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{moo}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{farmer}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{it looks like rain}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{dog}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{woof}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
The chicken says bawk
The cow says moo
The farmer says it looks like rain
The dog says woof
    \end{Verbatim}

    What if we include an argument without assigning it to a keyword?

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{43}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{PrintKwargs}\PY{p}{(}\PY{n}{chicken}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{bawk}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{cow}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{moo}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{farmer}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{it looks like rain}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{dog}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{woof}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{nothing assigned}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}, frame=single, framerule=2mm, rulecolor=\color{outerrorbackground}]
\textcolor{ansi-cyan}{  File }\textcolor{ansi-green}{"/tmp/ipykernel\_98113/3123196330.py"}\textcolor{ansi-cyan}{, line }\textcolor{ansi-green}{1}
\textcolor{ansi-red}{    PrintKwargs(chicken="bawk",cow="moo",farmer="it looks like rain",dog="woof","nothing assigned")}
                                                                                                  \^{}
\textcolor{ansi-red}{SyntaxError}\textcolor{ansi-red}{:} positional argument follows keyword argument

    \end{Verbatim}

    Not great. In this case, you get an error because there's something
passed to the function that isn't a keyword argument. As an aside, a
``positional argument'' is just the regular arguments we worked with in
the examples before \texttt{*args} and \texttt{**kwargs}.

What if we wanted to account for keyword arguments AND unassigned
arguments?

You can use positional arguments, \texttt{*args}, and \texttt{**kwargs}
in your function calls, so long as they're in that order.

Positional arguments may also have default values assigned to them in
the function definition. Any default variables should be placed at the
end of the \emph{positional arguments}, but before the \texttt{*args}
and \texttt{**kwargs}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{BigFunction}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{z}\PY{o}{=}\PY{l+m+mi}{10}\PY{p}{,}\PY{o}{*}\PY{n}{args}\PY{p}{,}\PY{o}{*}\PY{o}{*}\PY{n}{kwargs}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{x is}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{x}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{y is}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{y}\PY{p}{)}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{z is}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{z}\PY{p}{)}
    \PY{k}{for} \PY{n}{arg} \PY{o+ow}{in} \PY{n}{args}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Found arg: }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{arg}\PY{p}{)}
    \PY{k}{for} \PY{n}{key}\PY{p}{,}\PY{n}{value} \PY{o+ow}{in} \PY{n}{kwargs}\PY{o}{.}\PY{n}{items}\PY{p}{(}\PY{p}{)}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{keyword}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{key}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{is}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{value}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{BigFunction}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{bear}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{goat}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{llama}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{emu}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{shark}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{potato}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{mashed}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{dinner}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{ready}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
x is  3
y is  4
z is 6
Found arg:  bear
Found arg:  goat
Found arg:  llama
Found arg:  emu
Found arg:  shark
keyword potato is mashed
keyword dinner is ready
    \end{Verbatim}

    One thing to keep in mind is that positional arguments get assigned
before anything gets dumped into \texttt{*args}. Above, even though
\texttt{z} has a default value, it got assigned a value of \texttt{6}
from the function call because \texttt{6} was in that position.
Everything afterwards was combined into \texttt{*args}.
\section{Advanced Functions - Decorators and Wrappers}
You can nest functions inside other functions. In this way, you can
contain these nested functions to ensure they're only accessible inside
the outer functions. This can be useful if you want to ensure that any
data being used is processed in a specific way beforehand, depending on
the way you call the function.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k}{def} \PY{n+nf}{outer\PYZus{}function}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{inner\PYZus{}function1}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{was given.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{k}{def} \PY{n+nf}{inner\PYZus{}function2}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{is x squared}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{inner\PYZus{}function1}\PY{p}{(}\PY{n}{x}\PY{p}{)}
    \PY{n}{inner\PYZus{}function2}\PY{p}{(}\PY{n}{x}\PY{p}{)}

\PY{n}{outer\PYZus{}function}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
4 was given.
16 is x squared
    \end{Verbatim}

    As you can see, \texttt{outer\_function} calls its own
\texttt{inner\_function}s without issue. Let's try calling the
\texttt{inner\_function}s directly.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{inner\PYZus{}function1}\PY{p}{(}\PY{l+m+mi}{4}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}, frame=single, framerule=2mm, rulecolor=\color{outerrorbackground}]
\textcolor{ansi-red}{---------------------------------------------------------------------------}
\textcolor{ansi-red}{NameError}                                 Traceback (most recent call last)
\textcolor{ansi-green}{/tmp/ipykernel\_269786/3089592963.py} in \textcolor{ansi-cyan}{<module>}
\textcolor{ansi-green}{----> 1}\textcolor{ansi-red}{ }inner\_function1\textcolor{ansi-blue}{(}\textcolor{ansi-cyan}{4}\textcolor{ansi-blue}{)}

\textcolor{ansi-red}{NameError}: name 'inner\_function1' is not defined
    \end{Verbatim}

    Now we get an error. This is because the inner functions only exist in
the scope of the outer function. These small examples illustrate the
concept in a basic way, but let's consider a more complicated function.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{29}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}
\PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{ndimage} \PY{k+kn}{import} \PY{n}{gaussian\PYZus{}filter}
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{cm} \PY{k}{as} \PY{n+nn}{cm}

\PY{k}{def} \PY{n+nf}{plot\PYZus{}with\PYZus{}smoothing}\PY{p}{(}\PY{n}{data}\PY{p}{,}\PY{n}{sigma}\PY{p}{)}\PY{p}{:}
    \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}Takes data and a smoothing factor sigma and plots the raw data plus the smoothed data\PYZdq{}\PYZdq{}\PYZdq{}}
    \PY{n}{cmap} \PY{o}{=} \PY{n}{cm}\PY{o}{.}\PY{n}{get\PYZus{}cmap}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Reds\PYZus{}r}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{n}{fig} \PY{o}{=} \PY{n}{plt}\PY{o}{.}\PY{n}{figure}\PY{p}{(}\PY{n}{figsize}\PY{o}{=}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{n}{dpi}\PY{o}{=}\PY{l+m+mi}{300}\PY{p}{)}
    \PY{n}{ax} \PY{o}{=} \PY{n}{fig}\PY{o}{.}\PY{n}{add\PYZus{}subplot}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{k}{def} \PY{n+nf}{smoothing}\PY{p}{(}\PY{n}{data}\PY{p}{,}\PY{n}{sigma}\PY{p}{,}\PY{n}{color}\PY{p}{)}\PY{p}{:}
        \PY{l+s+sd}{\PYZdq{}\PYZdq{}\PYZdq{}Plots the smoothed data\PYZdq{}\PYZdq{}\PYZdq{}}
        \PY{n}{ax}\PY{o}{.}\PY{n}{plot}\PY{p}{(}\PY{n}{gaussian\PYZus{}filter}\PY{p}{(}\PY{n}{data}\PY{p}{,}\PY{n}{sigma}\PY{o}{=}\PY{n}{sigma}\PY{p}{)}\PY{p}{,}\PY{n}{color}\PY{o}{=}\PY{n}{color}\PY{p}{,}\PY{n}{lw}\PY{o}{=}\PY{l+m+mf}{0.5}\PY{p}{)}
    \PY{c+c1}{\PYZsh{} ax.plot(data,color=\PYZdq{}grey\PYZdq{},lw=0.5)}
    \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{sigma}\PY{p}{)}\PY{p}{:}
        \PY{n}{smoothing}\PY{p}{(}\PY{n}{data}\PY{p}{,}\PY{n}{i}\PY{p}{,}\PY{n}{cmap}\PY{p}{(}\PY{n}{i}\PY{o}{/}\PY{n}{sigma}\PY{p}{)}\PY{p}{)}

\PY{n}{data} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{rand}\PY{p}{(}\PY{l+m+mi}{10000}\PY{p}{)}
\PY{n}{plot\PYZus{}with\PYZus{}smoothing}\PY{p}{(}\PY{n}{data}\PY{p}{,}\PY{l+m+mi}{100}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_5_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    
    Internally defined functions can also allow you to use the same function
name in many different contexts. It can be helpful when you have
functions that are doing some small task a large number of times, but in
a different way depending on the context. In the above example,
\texttt{smoothing} works on 1-dimensional data. There are other
occasions where you may have 2-dimensional data, which requires
different techniques to smooth properly. Therefore, you might want to
ensure that the smoothing functions for 1-d data and 2-d data are kept
isolated to prevent misuse.

Internal functions can also be called as results of if-else statements
or other conditional checks.

    \hypertarget{advanced-functions---decorators}{%
\subsubsection{Advanced Functions -
Decorators}\label{advanced-functions---decorators}}

Decorators are another version of nested functions, but in the opposite
direction. Let's say you want to get timings for individual functions during program execution so you can see where the program spends the most time.  With decorators, you can simple wrap your other functions in another function that grabs the start and end times for that function and prints out how long it took to run.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{46}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} The function \PYZsq{}wrapper\PYZsq{} takes the function as an argument, and the nested function \PYZsq{}wrapped\PYZsq{} uses the incoming arguments in the external function.}
\PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} This allows you to pass arguments through a decorator.}
\PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} The decorator does its own stuff around the called function.}
\PY{k}{def} \PY{n+nf}{decorator\PYZus{}function}\PY{p}{(}\PY{n}{func}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{wrapper\PYZus{}function}\PY{p}{(}\PY{o}{*}\PY{n}{args}\PY{p}{,}\PY{o}{*}\PY{o}{*}\PY{n}{kwargs}\PY{p}{)}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Before the function!}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{n}{result} \PY{o}{=} \PY{n}{func}\PY{p}{(}\PY{o}{*}\PY{n}{args}\PY{p}{,}\PY{o}{*}\PY{o}{*}\PY{n}{kwargs}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{After the function!}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
        \PY{k}{return} \PY{n}{result}
    \PY{k}{return} \PY{n}{wrapper\PYZus{}function}


\PY{n+nd}{@decorator\PYZus{}function} \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Here\PYZsq{}s where we \PYZdq{}wrap\PYZdq{} the new function rather than having to nest the entire thing inside the decorator.}
\PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+sa}{f}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The value of x is }\PY{l+s+si}{\PYZob{}}\PY{n}{x}\PY{l+s+si}{\PYZcb{}}\PY{l+s+s2}{.  Returning x**2}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{k}{return} \PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}

\PY{n}{answer} \PY{o}{=} \PY{n}{f}\PY{p}{(}\PY{l+m+mi}{5}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{answer}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Before the function!
The value of x is 5.  Returning x**2
After the function!
25
    \end{Verbatim}

    Decorators are extremely useful tools, especially with larger projects.
You can also have multiple decorators on a single function, which can
further expand your code!

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{50}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{datetime} \PY{k+kn}{import} \PY{n}{datetime} \PY{k}{as} \PY{n}{dt}

\PY{k}{def} \PY{n+nf}{timing\PYZus{}wrapper}\PY{p}{(}\PY{n}{func}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{wrapped}\PY{p}{(}\PY{o}{*}\PY{n}{args}\PY{p}{,}\PY{o}{*}\PY{o}{*}\PY{n}{kwargs}\PY{p}{)}\PY{p}{:}
        \PY{n}{start} \PY{o}{=} \PY{n}{dt}\PY{o}{.}\PY{n}{now}\PY{p}{(}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Start time is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{start}\PY{p}{)}
        \PY{n}{result} \PY{o}{=} \PY{n}{func}\PY{p}{(}\PY{o}{*}\PY{n}{args}\PY{p}{,}\PY{o}{*}\PY{o}{*}\PY{n}{kwargs}\PY{p}{)}
        \PY{n}{end} \PY{o}{=} \PY{n}{dt}\PY{o}{.}\PY{n}{now}\PY{p}{(}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{End time is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{end}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Total Time:}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{end} \PY{o}{\PYZhy{}} \PY{n}{start}\PY{p}{)}
        \PY{k}{return} \PY{n}{result}
    \PY{k}{return} \PY{n}{wrapped}

\PY{n+nd}{@timing\PYZus{}wrapper}
\PY{n+nd}{@decorator\PYZus{}function}
\PY{k}{def} \PY{n+nf}{g}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
    \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{X is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{x}\PY{p}{,}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+se}{\PYZbs{}n}\PY{l+s+s2}{Returning \PYZhy{}X.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{k}{return} \PY{o}{\PYZhy{}}\PY{n}{x}

\PY{n}{g}\PY{p}{(}\PY{l+m+mi}{6}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
Start time is  2022-06-14 16:55:36.759226
Before the function!
X is  6
Returning -X.
After the function!
End time is  2022-06-14 16:55:36.759419
Total Time: 0:00:00.000193
    \end{Verbatim}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{50}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
-6
\end{Verbatim}
\end{tcolorbox}
        
    This shows us that the order of our decorators matters quite a bit. The
first decorator in the list is the outermost decorator, then the next
one, and so forth.

You can also include additional functionality inside decorators that can
make things easier in your code.

For example, let's say I have a function that opens a file and reads the
first line. I might want to be sure the file exists before I try to open
it. Now, this is something I can do in every function that has a file
being opened and read, which means more code being written and more to
sift through if something goes wrong. However, if I am consistent in my
variable naming conventions (most people develop a style of their own -
unless you work for a company with their own established style
requirements), I can do things like check for a file's existence before
passing the filename on to the reading function. Let's see how that
might look.

I'll use the \texttt{glob} library that comes standard with
\texttt{python}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{57}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{from} \PY{n+nn}{glob} \PY{k+kn}{import} \PY{n}{glob}

\PY{k}{def} \PY{n+nf}{check\PYZus{}file\PYZus{}exists}\PY{p}{(}\PY{n}{func}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{wrapper}\PY{p}{(}\PY{o}{*}\PY{n}{args}\PY{p}{,}\PY{o}{*}\PY{o}{*}\PY{n}{kwargs}\PY{p}{)}\PY{p}{:}
        \PY{k}{if} \PY{n}{glob}\PY{p}{(}\PY{n}{kwargs}\PY{p}{[}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{filename}\PY{l+s+s2}{\PYZdq{}}\PY{p}{]}\PY{p}{)}\PY{p}{:}
            \PY{k}{return} \PY{n}{func}\PY{p}{(}\PY{o}{*}\PY{n}{args}\PY{p}{,}\PY{o}{*}\PY{o}{*}\PY{n}{kwargs}\PY{p}{)}
        \PY{k}{else}\PY{p}{:}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{args}\PY{p}{)}
            \PY{n+nb}{print}\PY{p}{(}\PY{n}{kwargs}\PY{p}{)}
            \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{File does not exist}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
    \PY{k}{return} \PY{n}{wrapper}

\PY{n+nd}{@check\PYZus{}file\PYZus{}exists}
\PY{k}{def} \PY{n+nf}{read\PYZus{}first\PYZus{}line}\PY{p}{(}\PY{n}{filename}\PY{p}{)}\PY{p}{:}
    \PY{k}{with} \PY{n+nb}{open}\PY{p}{(}\PY{n}{filename}\PY{p}{)} \PY{k}{as} \PY{n}{f}\PY{p}{:}
        \PY{n+nb}{print}\PY{p}{(}\PY{n}{f}\PY{o}{.}\PY{n}{readline}\PY{p}{(}\PY{p}{)}\PY{p}{)}
    \PY{n}{f}\PY{o}{.}\PY{n}{close}\PY{p}{(}\PY{p}{)}

\PY{n}{read\PYZus{}first\PYZus{}line}\PY{p}{(}\PY{n}{filename}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{test.txt}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
\PY{n}{read\PYZus{}first\PYZus{}line}\PY{p}{(}\PY{n}{filename}\PY{o}{=}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{09\PYZus{}Functions\PYZus{}Advanced.ipynb}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)} \PY{c+c1}{\PYZsh{}\PYZsh{} This is this very notebook, so it should return an actual result... which is just a \PYZdq{}\PYZob{}\PYZdq{}.}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
()
\{'filename': 'test.txt'\}
File does not exist
\{

    \end{Verbatim}

    It should be noted that even though the \texttt{read\_first\_line}
function uses the positional argument ``filename'', if the function is
called without the explicit keyword argument
\texttt{filename="test.txt"}, there will be an error in the wrapper. So
take the knowledge that you can mess with parameters inside a wrapper
with a grain of salt - you can also make a big ol' mess.
\newpage
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{ }{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} For future use, here\PYZsq{}s a basic template!}
\PY{k}{def} \PY{n+nf}{decorator\PYZus{}name}\PY{p}{(}\PY{n}{func}\PY{p}{)}\PY{p}{:}
    \PY{k}{def} \PY{n+nf}{wrapper}\PY{p}{(}\PY{o}{*}\PY{n}{args}\PY{p}{,}\PY{o}{*}\PY{o}{*}\PY{n}{kwargs}\PY{p}{)}\PY{p}{:}
        \PY{k}{return} \PY{n}{func}\PY{p}{(}\PY{o}{*}\PY{n}{args}\PY{p}{,}\PY{o}{*}\PY{o}{*}\PY{n}{kwargs}\PY{p}{)}
    \PY{k}{return} \PY{n}{wrapper}
\end{Verbatim}
\end{tcolorbox}
