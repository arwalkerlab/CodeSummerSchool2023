\chapter{Day 9 - Headers, Libraries, and Makefiles}
\begin{Goals}
\begin{enumerate}
    \item Understand libraries and headers
    \item Develop your own header files
    \item Understand the basics of how Makefiles work
\end{enumerate}
\end{Goals}

\section{How Libraries and Header Files Work}
Libraries and headers both allow you to add additional functionality to your programs without having to code them all from scratch. However, there are some differences between them.

\subsection{Headers}
Headers are plain-text files that contain information used in libraries, such as new data types, constants, library-specific classes, and function declarations.  Headers are added to programs with the \texttt{\#include} command that we're familiar with.  By convention, header files end in \texttt{.h}, 

Below is an example header file.

\begin{minted}{c++}
// geometry.h
#ifndef GEOMETRY_H // include guard
#define GEOMETRY_H
namespace geom
{
    const double PI = 3.1415;
    class Circle 
    {
        double radius;
      public:
        void set_radius(double);
        double area();
        double circumference();
    };
}
#endif /* GEOMETRY_H */
\end{minted}

There are a few important features to point out.  First, the three lines that act as "guards" are important to ensure that the compiler won't try to redefine things over and over, or bloat the final program with repeated functions.  The first part of the guard has the \texttt{\#ifndef} and \texttt{\#define} lines.  These two tell the compiler that if it has not already defined \texttt{GEOMETRY\_H}, it should do so.  In this way, even if you have a hundred different source files that use the header file, it will only be compiled and linked once.  The final guard, \texttt{\#endif}, concludes the instructions that followed the first two guards.  Everything between the guards is part of that particular header/library combination.

Next is the \texttt{namespace geom} scope.  
This is the same concept we encountered in the earlier lessons with \texttt{std::cout} or the later command \texttt{using namespace std;}.  
In this case, a namespace called \texttt{geom} is created.  
The class contained within that namespace would be called using \texttt{geom::Circle}, and any functions inside would use a similar call.  
However, if our code includes \texttt{using namespace geom;} after including this header file, we can use the internal classes and functions without the \texttt{geom::} requirement, similar to how we are able to skip using \texttt{std::} in previous code examples.

Headers can be written without namespaces, however you will want to be careful of your function, class, and variable names and be sure they don't conflict with anything else in use in any of the libraries or source codes you're using.  In general, it's recommended that anything you create be contained in a namespace.

\subsection{Libraries}
Libraries are sometimes already compiled into machine language and are not "human-readable" files.  Libraries are usually accessed during compilation of your main program as part of the linking process.  Many pre-compiled libraries are available for free, and learning their use can provide improved access to hardware-specific functionality or better algorithms without having to create them all yourself.  The source code for libraries is usually written in the same language and format as their associated header files.  Where headers had only declarations, library source files will have the complete function definition, class definitions, etc.

Below is an example library source file to go with the above header file.

\begin{minted}{c++}
// geometry.cpp
#include "geometry.h"
void geom::Circle::set_radius(int r)
{
    radius = r;
}
void geom::Circle::area()
{
    return PI * radius * radius;
}
void geom::Circle::circumference()
{
    return PI * radius * 2.0;
}
\end{minted}

With both the \texttt{geometry.h} and \texttt{geometry.cpp} files written, a main program file might look like the following.

\begin{minted}{c++}
#include <iostream>
#include "geometry.h"

int main()
{
    geom::Circle my_circle;
    my_circle.set_radius(2.5);
    std::cout << "Area of the circle is " << my_circle.area() << std::endl;
    std::cout << "Circumference of the circle is " << my_circle.circumference() << std::endl;
    return 0;
}
\end{minted}

\section{Makefiles}
Makefiles are a set of instructions for the compiler to use to build more complex programs from multiple files.  Previously, all of our programs have been single source code files containing everything needed.

Effectively, each makefile is a list of object files that are created by compiling source code files, and include any dependencies.  This way, if you make a change to one file, only that file and any dependent files are recompiled and linked, rather than the entire program (which can take hours or even days to complete, depending on the size of the program in question).

Each individual piece of the compilation process is written in a specific format, shown below.

\begin{minted}{bash}
## location of header files
export INCLUDE_DIR=./headers/

executable.x: executable.cpp subfile1.o subfile2.o
    g++ executable.cpp subfile1.o subfile2.o -o executable.x -I ${INCLUDE_DIR}
    
subfile1.o: subfile1.cpp
    g++ subfile1.cpp -o subfile1.o -I ${INCLUDE_DIR}
    
subfile2.o: subfile2.cpp
    g++ subfile2.cpp -o subfile2.o -I ${INCLUDE_DIR}
\end{minted}

First, we establish any necessary environment variables for the compilation using the \texttt{export} command.  Then, each object to be created is listed with any dependencies.  In the example above, \texttt{executable.x} (the final executable file) is dependent on the file \texttt{executable.cpp} (the source code for that particular output) and the object files \texttt{subfile1.o} and \texttt{subfile2.o}.  When the makefile is run, the compiler checks to see if \texttt{executable.x} exists \textit{and is newer than } all of its dependencies.  What this means is that if any of the dependencies have been changed since the last time \texttt{executable.x} was compiled, it will be recompiled with the command on the line below, beginning with \texttt{g++}.

The compile line for each object being created begins with the compiler itself, then lists any and all source files and objects to be linked, the uses the \texttt{-o} flag to indicate the name of the output object, and \texttt{-I} for any additional file locations it should include when compiling (such as the location of all header files in the project).

If you're wondering what the \texttt{.o} files are, they're "object" files, and are effectively the intermediate steps between the raw source code of an entire project and the completed final compilation into a single executable file.  Objects are compiled \textit{portions} of the program, and when they're included in the compile command shown above, the process is called "linking".

This allows us to connect multiple separate files together without having to fully recompile everything.  Each object file is listed in the Makefile in the same way as the example above, with only the filenames of dependencies and outputs being changed.
