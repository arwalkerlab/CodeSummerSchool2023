\section{Library - Numpy}
One of the most popular python libraries is \texttt{numpy}, which can be
found in hundreds of other libraries. NumPy takes advantage of the speed
of C++ and FORTRAN code while being usable inside python, making it
extremely powerful. As their own website states, ``A solution in NumPy
is often clear and elegant''.

We'll cover some of the basic or common functions below to get started,
but keep in mind that there is quite a bit more that numpy can do to
make your python-coding life easier. NumPy has no dependencies outside
of python itself. It also comes standard with most python installations
(like Anaconda). Loading numpy is therefore simple. The convention is to
use the code below.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\end{Verbatim}
\end{tcolorbox}

    NumPy is most often associated with the ``numpy array'', which is
effectively a list of elements. However, the \texttt{numpy} library
takes the array to a higher level and has a lot more included
functionality. Let's look at how a basic array can be made with
\texttt{numpy}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{my\PYZus{}array} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{100}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{my\PYZus{}array}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47
 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71
 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95
 96 97 98 99]
    \end{Verbatim}

    We can see the use of \texttt{np.arange} above. It has two required
arguments for the start and ending values. Note that in the code above,
the end value is 100, but the actual list stops at 99. This means if you
actually want 0 to 100, you should set an end value of 101.

We can also add a third value for stride, or how much to increment the
value.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{my\PYZus{}array} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{arange}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{100}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{my\PYZus{}array}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
[ 0  5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95]
    \end{Verbatim}

    In the example above, we get values that are 5 apart. If we adjust the
end point to 101, we'll get the last value (100) as well.

If we want to get a range of values that are evenly spaced between two
endpoints \emph{and includes both of those endpoints}, we can use the
\texttt{linspace} function. The \texttt{linspace} function requires
three values - start, end, and number of values to return. It is
important to keep in mind how the array is created in this function. If
a set of N values is requested between X and Y, it will calculate the
increment as follows:

\[ I = \frac{Y-X}{N-1} \]

This will produce values of \([X, X+I, X+2I, ..., X+(N-1)I, Y]\), which
are equally spaced.

The reason this is being explained is shown below. If we wanted 20
values between 0 and 10, we might intuitively think it would give us
increments of 0.5, so that the array would look like
\([0,0.5,1.0,1.5,...]\). However, the \texttt{linspace} array includes
both endpoints in the list.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{13}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{my\PYZus{}array} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{,}\PY{l+m+mi}{20}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{my\PYZus{}array}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
[ 0.          0.52631579  1.05263158  1.57894737  2.10526316  2.63157895
  3.15789474  3.68421053  4.21052632  4.73684211  5.26315789  5.78947368
  6.31578947  6.84210526  7.36842105  7.89473684  8.42105263  8.94736842
  9.47368421 10.        ]
    \end{Verbatim}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{14}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{my\PYZus{}array} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,}\PY{l+m+mi}{10}\PY{p}{,}\PY{l+m+mi}{21}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{my\PYZus{}array}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
[ 0.   0.5  1.   1.5  2.   2.5  3.   3.5  4.   4.5  5.   5.5  6.   6.5
  7.   7.5  8.   8.5  9.   9.5 10. ]
    \end{Verbatim}

    Another function in \texttt{numpy} is the \texttt{roll} function. This
treats the array like a closed loop and lets you move all elements some
number of spaces down, looping end elements back to the start.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{np}\PY{o}{.}\PY{n}{roll}\PY{p}{(}\PY{n}{my\PYZus{}array}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)} \PY{c+c1}{\PYZsh{} shift everything 1 space over, brings the last element to the front.}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{20}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
array([10. ,  0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ,  3.5,  4. ,  4.5,
        5. ,  5.5,  6. ,  6.5,  7. ,  7.5,  8. ,  8.5,  9. ,  9.5])
\end{Verbatim}
\end{tcolorbox}
        
    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{19}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{np}\PY{o}{.}\PY{n}{roll}\PY{p}{(}\PY{n}{my\PYZus{}array}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{)} \PY{c+c1}{\PYZsh{} Shift everything 3 spaces over.}
\end{Verbatim}
\end{tcolorbox}

            \begin{tcolorbox}[breakable, size=fbox, boxrule=.5pt, pad at break*=1mm, opacityfill=0]
\prompt{Out}{outcolor}{19}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
array([ 9. ,  9.5, 10. ,  0. ,  0.5,  1. ,  1.5,  2. ,  2.5,  3. ,  3.5,
        4. ,  4.5,  5. ,  5.5,  6. ,  6.5,  7. ,  7.5,  8. ,  8.5])
\end{Verbatim}
\end{tcolorbox}
        
    \hypertarget{numpy.linalg}{%
\subsubsection{numpy.linalg}\label{numpy.linalg}}

NumPy has a number of submodules that are useful for certain tasks. The
\texttt{linalg} submodule is short for Linear Algebra, which is focused
on vector-, matrix-, and tensor-math functions. Most of the things you
learn to calculate by hand in a multivariable calculus course can be
done with simple functions in \texttt{numpy.linalg}

For example, if you have a vector \([1,2,3]\), you can get the magnitude
of the vector by using \texttt{linalg.norm}.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{21}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy}\PY{n+nn}{.}\PY{n+nn}{linalg} \PY{k}{as} \PY{n+nn}{la}

\PY{n}{my\PYZus{}vector}\PY{o}{=}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{la}\PY{o}{.}\PY{n}{norm}\PY{p}{(}\PY{n}{my\PYZus{}vector}\PY{p}{)}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
3.7416573867739413
    \end{Verbatim}

    You can also do more complicated operations like the dot-product or
cross-products

\hypertarget{np.dot}{%
\paragraph{np.dot()}\label{np.dot}}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{25}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{vec1} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}
\PY{n}{vec2} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{]}
\PY{n}{dot\PYZus{}product} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{dot}\PY{p}{(}\PY{n}{vec1}\PY{p}{,}\PY{n}{vec2}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{dot\PYZus{}product}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
32
    \end{Verbatim}

    \hypertarget{np.cross}{%
\paragraph{np.cross()}\label{np.cross}}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{36}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{mat1} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+m+mi}{3}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{4}\PY{p}{,}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{7}\PY{p}{,}\PY{l+m+mi}{8}\PY{p}{,}\PY{l+m+mi}{9}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n}{mat2} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{l+m+mi}{5}\PY{p}{,}\PY{l+m+mi}{6}\PY{p}{]}\PY{p}{]}\PY{p}{)}
\PY{n}{cross\PYZus{}product} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{cross}\PY{p}{(}\PY{n}{mat1}\PY{p}{,}\PY{n}{mat2}\PY{p}{)}

\PY{n+nb}{print}\PY{p}{(}\PY{n}{mat1}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{mat2}\PY{p}{)}
\PY{n+nb}{print}\PY{p}{(}\PY{n}{cross\PYZus{}product}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{Verbatim}[commandchars=\\\{\}]
[[1 2 3]
 [4 5 6]
 [7 8 9]]
[[1 2]
 [3 4]
 [5 6]]
[[ -6   3   0]
 [-24  18   1]
 [-54  45   2]]
    \end{Verbatim}

    \hypertarget{random-number-generators}{%
\subsubsection{Random Number
Generators}\label{random-number-generators}}

Numpy is also home to a good selection of random number generators that
can provide different random distributions depending on what kind of
random number you need. - uniform - normal (Gaussian) - exponential -
binomial - etc.

\hypertarget{polynomial-fits}{%
\subsubsection{Polynomial Fits}\label{polynomial-fits}}

\texttt{numpy.polynomial} can provide you with data fitting tools to
obtain \(N\)-degree polynomials for your data.
