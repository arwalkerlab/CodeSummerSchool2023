\section{Functions Project}
Let's try creating some other functions, perhaps based on the pseudocode
project from last time.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Write a function to generate a random set of coordinates for a
  particle in a cube with an edge length of 20.
\item
  Write a function to create a list of \texttt{N} randomly placed
  particles.
\item
  Write a function to generate a random movement of a particle with each
  \texttt{x}, \texttt{y}, and \texttt{z} component of the motion vector
  as a random value between -1 and +1.
\item
  Write a function to make each particle in the list take \texttt{S}
  number of random motion steps.
\item
  Write a function to measure the distance between the starting and
  ending points of all particles.
\end{enumerate}

I will include some helper functions for things like random number
generation below. For all functions you'll write below, you will need to
choose what arguments you need to pass to the function and how to get to
the result at the \texttt{return} statement ending each function.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{1}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
\PY{k+kn}{import} \PY{n+nn}{matplotlib}\PY{n+nn}{.}\PY{n+nn}{pyplot} \PY{k}{as} \PY{n+nn}{plt}

\PY{k}{def} \PY{n+nf}{random}\PY{p}{(}\PY{n}{lower}\PY{p}{,}\PY{n}{upper}\PY{p}{)}\PY{p}{:}
    \PY{k}{return} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{uniform}\PY{p}{(}\PY{n}{low}\PY{o}{=}\PY{n}{lower}\PY{p}{,} \PY{n}{high}\PY{o}{=}\PY{n}{upper}\PY{p}{)}

\PY{k}{def} \PY{n+nf}{plot\PYZus{}distances}\PY{p}{(}\PY{n}{distances}\PY{p}{)}\PY{p}{:}
    \PY{n}{plt}\PY{o}{.}\PY{n}{hist}\PY{p}{(}\PY{n}{distances}\PY{p}{,} \PY{n}{bins}\PY{o}{=}\PY{l+m+mi}{100}\PY{p}{,} \PY{n}{density}\PY{o}{=}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{n}{plt}\PY{o}{.}\PY{n}{show}\PY{p}{(}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{2}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Generate particle with random position [x,y,z]}
\PY{k}{def} \PY{n+nf}{CreateParticle}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Your code goes here!}

    \PY{k}{return} \PY{n}{particle}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{3}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Create a list of N randomly generated particles}
\PY{k}{def} \PY{n+nf}{GenerateParticleCollection}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Your code goes here!}
    
    \PY{k}{return} \PY{n}{all\PYZus{}particles}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{4}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} generate a random motion between \PYZhy{}1 and 1 in all axes and apply it to a given particle.}
\PY{k}{def} \PY{n+nf}{MoveParticle}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Your code goes here!}

    \PY{k}{return} \PY{n}{new\PYZus{}position}
    
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{5}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Move all particles in your list S number of times and return the final positions.}
\PY{k}{def} \PY{n+nf}{BrownianMotionSimulation}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Your code goes here!}
    
    \PY{k}{return} \PY{n}{final\PYZus{}positions}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{6}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} Compare starting and ending positions for all particles and return the distances.}
\PY{k}{def} \PY{n+nf}{CalculateDistances}\PY{p}{(}\PY{p}{)}\PY{p}{:}
    \PY{c+c1}{\PYZsh{}\PYZsh{}\PYZsh{} Your code goes here!}

    \PY{k}{return} \PY{n}{distances}
\end{Verbatim}
\end{tcolorbox}

    Now write a sequence of function calls, variable assignments, etc. to
run through your algorithm.

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{7}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} This is your main \PYZdq{}program\PYZdq{}, which will use the functions you\PYZsq{}ve written and return a nice histogram of the resulting distances traveled by each particle.}

\PY{c+c1}{\PYZsh{} Generate 10000 particles}

\PY{c+c1}{\PYZsh{} Move the particles 100 steps.}

\PY{c+c1}{\PYZsh{} Measure the distances between starting and ending positions.}

\PY{c+c1}{\PYZsh{} use the `plot\PYZus{}distances()` function call to show the results as a histogram.}
\end{Verbatim}
\end{tcolorbox}

    If you got a histogram plot that looks like it could be the results of
the random motion of 10,000 particles, your program probably works
great!

Now that we've all completed that, let's consider some additional things
about the algorithm and the \emph{actual} execution of it.

For example, does the distance travelled have any dependency on the
original position of the particles? If not, what can we do to reduce the
amount of work being done by the computer? Can we reduce the entire
program down to something smaller?

Programming is often thought of as ``make the computer do a task'',
which is true, but in the larger picture of scientific programming, it's
important to consider the actual goals.

If we re-examine the actual goal of ``obtain a distribution of how far
particles will travel given random motion'', we can reduce the algorithm
down significantly.

\begin{itemize}
\tightlist
\item
  The x, y, and z components of motion are all generated the same way
  and independently of each other.
\item
  Each particle's motion is independent of all the other particles, as
  is its final distance traveled.
\item
  The final distance is independent of the starting coordinates.
\end{itemize}

With these points in mind, can you think of a new form of the algorithm?

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{8}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{c+c1}{\PYZsh{} start empty list of distances}
\PY{c+c1}{\PYZsh{} loop through number of particles to test}
    \PY{c+c1}{\PYZsh{} start particle position at 0,0,0}
    \PY{c+c1}{\PYZsh{} make S number of x moves, sum them up to a final x position}
    \PY{c+c1}{\PYZsh{} make S number of y moves, sum them up to a final y position}
    \PY{c+c1}{\PYZsh{} make S number of z moves, sum them up to a final z position}
    \PY{c+c1}{\PYZsh{} calculate norm of x,y,z coordinates}
    \PY{c+c1}{\PYZsh{} append norm to list of distances.}
\PY{c+c1}{\PYZsh{} plot histogram of distances}
\end{Verbatim}
\end{tcolorbox}

    \begin{tcolorbox}[breakable, size=fbox, boxrule=1pt, pad at break*=1mm,colback=cellbackground, colframe=cellborder]
\prompt{In}{incolor}{9}{\boxspacing}
\begin{Verbatim}[commandchars=\\\{\}]
\PY{n}{distances} \PY{o}{=} \PY{p}{[}\PY{p}{]}
\PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{10000}\PY{p}{)}\PY{p}{:}
    \PY{n}{x}\PY{o}{=}\PY{l+m+mi}{0}
    \PY{n}{y}\PY{o}{=}\PY{l+m+mi}{0}
    \PY{n}{z}\PY{o}{=}\PY{l+m+mi}{0}
    \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1000}\PY{p}{)}\PY{p}{:}
        \PY{n}{x} \PY{o}{+}\PY{o}{=} \PY{n}{random}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
        \PY{n}{y} \PY{o}{+}\PY{o}{=} \PY{n}{random}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
        \PY{n}{z} \PY{o}{+}\PY{o}{=} \PY{n}{random}\PY{p}{(}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{)}
    \PY{n}{norm} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linalg}\PY{o}{.}\PY{n}{norm}\PY{p}{(}\PY{p}{[}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{,}\PY{n}{z}\PY{p}{]}\PY{p}{)}
    \PY{n}{distances}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{n}{norm}\PY{p}{)}

\PY{n}{plot\PYZus{}distances}\PY{p}{(}\PY{n}{distances}\PY{p}{)}
\end{Verbatim}
\end{tcolorbox}

    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_11_1.png}
    \end{center}
    { \hspace*{\fill} \\}
